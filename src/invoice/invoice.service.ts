/**
 * Invoice Service
 *
 * Orchestrates business logic for invoices: formatting data for ZATCA (UBL XML),
 * triggering the signing process, and interacting with ZATCA APIs via helper services.
 */
import {
  Injectable,
  Logger,
  BadRequestException,
  NotFoundException,
} from "@nestjs/common";
import { CliExecutorService } from "../common/cli-executor.service";
import { FileManagerService } from "../common/file-manager.service";
import { XmlTemplateService } from "./xml-template.service";
import { SignInvoiceDto } from "./dto/sign-invoice.dto";
import * as path from "path";

import { SequenceService } from "../common/sequence.service";
import { PrismaService } from "../prisma/prisma.service";
import { ComplianceService } from "../compliance/compliance.service";
import { InvoiceRepository } from "./invoice.repository";

@Injectable()
export class InvoiceService {
  private readonly logger = new Logger(InvoiceService.name);

  constructor(
    private readonly cliExecutor: CliExecutorService,
    private readonly fileManager: FileManagerService,
    private readonly xmlTemplate: XmlTemplateService,
    private readonly sequenceService: SequenceService,
    private readonly prisma: PrismaService,
    private readonly complianceService: ComplianceService,
    private readonly invoiceRepository: InvoiceRepository
  ) {}

  async signInvoice(dto: SignInvoiceDto) {
    const { egs, invoice } = dto;
    const commonName = egs.commonName;

    this.logger.log("[SIGN_INVOICE] Starting invoice signing...");
    this.logger.debug(`[SIGN_INVOICE] Common Name: ${commonName}`);
    this.logger.debug(
      `[SIGN_INVOICE] Invoice Type Code: ${invoice.invoiceTypeCode}`
    );
    this.logger.debug(
      `[SIGN_INVOICE] Invoice Type Code Name: ${invoice.invoiceTypeCodeName}`
    );
    this.logger.debug(`[SIGN_INVOICE] Is Production: ${egs.production}`);

    // 1. Generate Sequence and Retrieve Chain Data (ICV and PIH)
    const seqData = await this.sequenceService.generateNextSerialNumber(dto);

    invoice.invoiceSerialNumber = seqData.serialNumber;
    invoice.invoiceCounterNumber = seqData.counter;
    invoice.previousInvoiceHash = seqData.previousHash;

    const serialNumber = invoice.invoiceSerialNumber;

    // 1. Load Keys and Certificate from DB (EgsUnit)
    const egsUnit = await this.prisma.egsUnit.findUnique({
      where: { commonName },
    });

    if (!egsUnit || !egsUnit.privateKey || !egsUnit.binarySecurityToken) {
      throw new NotFoundException(
        `Security tokens (key/cert) not found in database for ${commonName}. Please complete onboarding (steps 1 & 2) first.`
      );
    }

    // Reconstruct PEM-formatted key and certificate from compact DB values
    const formatPem = (body: string, header: string, footer: string) => {
      const chunks = body.match(/.{1,64}/g) || [body];
      return [header, ...chunks, footer, ""].join("\n");
    };

    const keyPem = formatPem(
      egsUnit.privateKey.trim(),
      "-----BEGIN PRIVATE KEY-----",
      "-----END PRIVATE KEY-----"
    );

    const certPem = formatPem(
      egsUnit.binarySecurityToken.trim(),
      "-----BEGIN CERTIFICATE-----",
      "-----END CERTIFICATE-----"
    );

    // Persist to onboarding folder to keep CLI contract unchanged
    const keyPath = await this.fileManager.writeOnboardingFile(
      commonName,
      "egs-signing-key.pem",
      keyPem
    );
    const certPath = await this.fileManager.writeOnboardingFile(
      commonName,
      "ccsid-certificate.pem",
      certPem
    );

    // 2. Generate Base XML
    this.logger.debug("[XML_GEN] Generating base XML from template...");
    const baseXml = this.xmlTemplate.generateInvoiceXml(dto);
    this.logger.debug(`[XML_GEN] Base XML length: ${baseXml.length} bytes`);

    const unsignedPath = await this.fileManager.writeTempFile(
      commonName,
      `${serialNumber}_unsigned.xml`,
      baseXml
    );
    const tempDir = await this.fileManager.getTempDir(commonName);
    const signedPath = path.join(tempDir, `${serialNumber}_signed.xml`);

    // 3. Call Fatoora CLI to Sign
    try {
      const command = `fatoora -sign -invoice "${unsignedPath}" -key "${keyPath}" -cert "${certPath}" -signedInvoice "${signedPath}"`;
      await this.cliExecutor.execute(command);

      if (!(await this.fileManager.exists(signedPath))) {
        throw new Error(
          "Signed invoice file was not generated by Fatoora CLI."
        );
      }

      const signedXml = await this.fileManager.readFile(signedPath);
      this.logger.log("[SIGN] Signed XML generated successfully");
      this.logger.debug(`[SIGN] Signed XML length: ${signedXml.length} bytes`);

      // Extract UUID from signed XML
      const uuidMatch = signedXml.match(/<cbc:UUID>([^<]+)<\/cbc:UUID>/);
      const extractedUUID = uuidMatch ? uuidMatch[1].trim() : "NOT_FOUND";
      this.logger.debug(`[EXTRACTION] Invoice UUID: ${extractedUUID}`);

      // Extract Hash from signed XML
      const hashMatch = signedXml.match(/URI=""[\s\S]*?DigestValue>([^<]+)</);
      const extractedHash = hashMatch ? hashMatch[1].trim() : "NOT_FOUND";
      this.logger.debug(`[EXTRACTION] Invoice Hash: ${extractedHash}`);

      // Extract QR code from signed XML for the frontend
      const qrMatch = signedXml.match(
        /<cac:AdditionalDocumentReference>\s*<cbc:ID>QR<\/cbc:ID>\s*<cac:Attachment>\s*<cbc:EmbeddedDocumentBinaryObject[^>]*>([^<]+)<\/cbc:EmbeddedDocumentBinaryObject>/i
      );
      const qrCode = qrMatch ? qrMatch[1].trim() : undefined;
      this.logger.debug(`[QR] QR Code extracted: ${qrCode ? "YES" : "NO"}`);

      // 4. PERSIST INVOICE TO DATABASE
      this.logger.log("[DB] Persisting invoice to database...");

      const savedInvoice = await this.persistInvoiceToDatabase(
        dto,
        signedXml,
        qrCode,
        serialNumber
      );

      this.logger.log("[DB] Invoice persisted successfully");
      this.logger.debug(`[DB] Invoice ID: ${savedInvoice.id}`);
      this.logger.debug(`[DB] Invoice UUID: ${savedInvoice.uuid}`);

      // IMPORTANT: Only increment counter after successful save
      await this.sequenceService.commitCounterIncrement(commonName);
      this.logger.log("[COUNTER] Invoice counter incremented successfully");

      return {
        invoiceId: savedInvoice.id,
        invoiceUuid: savedInvoice.uuid,
        signedXml,
        qrCode,
        fileName: `${serialNumber}_signed.xml`,
        message: "Invoice signed and saved successfully.",
      };
    } catch (error) {
      this.logger.error(`Fatoora Signing Failed: ${error.message}`);
      throw new BadRequestException(`ZATCA Signing Error: ${error.message}`);
    } finally {
      // CLEANUP: Remove temporary files to avoid storage
      try {
        if (unsignedPath) await this.fileManager.deleteTemp(unsignedPath);
        if (signedPath && (await this.fileManager.exists(signedPath))) {
          await this.fileManager.deleteTemp(signedPath);
        }
      } catch (cleanupError) {
        this.logger.warn(`⚠️ CLEANUP FAILED: ${cleanupError.message}`);
      }
    }
  }

  async listInvoices(commonName: string) {
    return this.invoiceRepository.findAllByCommonName(commonName);
  }

  async getInvoiceByNumber(invoiceNumber: string) {
    const invoice =
      await this.invoiceRepository.findByInvoiceNumber(invoiceNumber);

    if (!invoice) {
      throw new NotFoundException(`Invoice ${invoiceNumber} not found`);
    }

    return invoice;
  }

  async getZatcaResponse(invoiceNumber: string) {
    const submission =
      await this.invoiceRepository.findSubmissionByInvoiceNumber(invoiceNumber);

    if (!submission) {
      throw new NotFoundException(
        `Submission record for ${invoiceNumber} not found`
      );
    }

    return submission.zatcaResponse;
  }

  /**
   * Persists the complete invoice to the database following the Prisma schema structure
   * EXTRACTS all data from the CLI-generated signed XML (no custom logic)
   * Includes extensive logging for debugging every step
   */
  private async persistInvoiceToDatabase(
    dto: SignInvoiceDto,
    signedXml: string,
    qrCode: string | undefined,
    serialNumber: string
  ) {
    const { egs, invoice, supplier, customer, lineItems, totals } = dto;

    // =====================================================
    // EXTRACT DATA FROM CLI-GENERATED SIGNED XML
    // =====================================================

    // Extract UUID (generated by Fatoora CLI)
    const uuidMatch = signedXml.match(/<cbc:UUID>([^<]+)<\/cbc:UUID>/);
    const cliGeneratedUuid = uuidMatch ? uuidMatch[1].trim() : null;

    // Extract Issue Date/Time (generated by Fatoora CLI)
    const issueDateMatch = signedXml.match(
      /<cbc:IssueDate>([^<]+)<\/cbc:IssueDate>/
    );
    const issueTimeMatch = signedXml.match(
      /<cbc:IssueTime>([^<]+)<\/cbc:IssueTime>/
    );

    let cliIssueDateTime = new Date();
    if (issueDateMatch && issueTimeMatch) {
      const dateStr = issueDateMatch[1].trim();
      const timeStr = issueTimeMatch[1].trim();
      cliIssueDateTime = new Date(`${dateStr}T${timeStr}`);
    }

    // Extract Invoice Hash (PIH - Previous Invoice Hash from XML)
    const pihMatch = signedXml.match(
      /<cbc:ID>PIH<\/cbc:ID>[\s\S]*?<cbc:EmbeddedDocumentBinaryObject[^>]*>([^<]+)<\/cbc:EmbeddedDocumentBinaryObject>/
    );
    const previousInvoiceHash = pihMatch
      ? pihMatch[1].trim()
      : "NWZlY2ViOTZmOTk1YTRiMGNjM2YwOTUwZGYzMmM2YjQ5ZGEyN2IyOA==";

    // Extract Invoice Counter (ICV) from XML
    // const icvMatch = signedXml.match(
    //   /<cbc:ID>ICV<\/cbc:ID>[\s\S]*?<cbc:EmbeddedDocumentBinaryObject[^>]*>([^<]+)<\/cbc:EmbeddedDocumentBinaryObject>/
    // );
    // const invoiceCounter = icvMatch
    //   ? icvMatch[1].trim()
    //   : invoice.invoiceCounterNumber?.toString() || "1";

    // Extract Actual Invoice Hash (Digest Value for ZATCA)
    const invoiceHashMatch = signedXml.match(
      /URI=""[\s\S]*?DigestValue>([^<]+)</
    );
    const currentInvoiceHash = invoiceHashMatch
      ? invoiceHashMatch[1].trim()
      : "HASH_NOT_FOUND";

    if (!cliGeneratedUuid) {
      throw new BadRequestException(
        "Failed to extract UUID from signed XML. CLI may have failed."
      );
    }

    try {
      // Step 1: Create main Invoice record using CLI-extracted data
      const createdInvoice = await this.invoiceRepository.create({
        invoiceNumber: serialNumber,
        uuid: cliGeneratedUuid, // ✅ USE CLI-GENERATED UUID
        invoiceTypeCode: invoice.invoiceTypeCode,
        invoiceTypeCodeName:
          invoice.invoiceTypeCodeName ||
          (customer?.type === "B2B" ? "0111010" : "0211010"),
        invoiceCategory: customer?.type === "B2B" ? "STANDARD" : "SIMPLIFIED",
        issueDateTime: cliIssueDateTime, // ✅ USE CLI-GENERATED TIMESTAMP

        // EGS Reference
        egsUnit: { connect: { commonName: egs.commonName } },

        // Seller Info (detailed address)
        sellerName: supplier.registrationName,
        sellerVatNumber: supplier.vatNumber,
        sellerStreet: supplier.address.street || "Unknown",
        sellerBuildingNumber: supplier.address.buildingNumber || "0000",
        sellerCity: supplier.address.city || "Riyadh",
        sellerDistrict: supplier.address.district || "District",
        sellerCountryCode: supplier.address.country || "SA",
        sellerPostalCode: supplier.address.postalCode || "00000",

        // Buyer Info (Optional for B2C)
        buyerName: customer?.name || null,
        buyerVatNumber: customer?.vatNumber || null,
        buyerStreet: customer?.address?.street || null,
        buyerBuildingNumber: customer?.address?.buildingNumber || null,
        buyerCity: customer?.address?.city || null,
        buyerDistrict: customer?.address?.district || null,
        buyerCountryCode: customer?.address?.country || null,
        buyerPostalCode: customer?.address?.postalCode || null,

        // References (for Credit/Debit Notes)
        referenceInvoiceNumber: invoice.billingReferenceId || null,
        referenceUUID: null,
        referenceIssueDate: null,

        // Advance Payments
        prepaidAmount: 0,
        remainingAmount: totals.taxInclusiveTotal,

        // Totals (from request DTO)
        subTotal: totals.taxExclusiveTotal,
        vatAmount: totals.vatTotal,
        totalAmount: totals.taxInclusiveTotal,
        currency: invoice.currency || "SAR",

        // Signed XML (CLI output)
        signedXml: signedXml,
        qrCode: qrCode || null,

        // Status
        status: "ISSUED",
      });

      // Step 2: Create Line Items
      const itemsData = lineItems.map((item) => {
        return {
          invoiceId: createdInvoice.id,
          description: item.description,
          quantity: item.quantity,
          unitPrice: item.unitPrice,
          vatRate: item.vatPercent,
          vatAmount: item.vatAmount,
          totalAmount: item.taxExclusiveAmount + item.vatAmount,
        };
      });

      await this.invoiceRepository.createItems(itemsData);

      // Step 3: Create Invoice Hash Record (using CLI-extracted hash)
      await this.invoiceRepository.createHash({
        invoice: { connect: { id: createdInvoice.id } },
        previousInvoiceHash: previousInvoiceHash, // ✅ FROM CLI XML (PIH)
        currentInvoiceHash: currentInvoiceHash, // ✅ ACTUAL HASH (DigestValue)
      });

      // Step 4: Initialize ZATCA Submission Record
      const submissionType =
        customer?.type === "B2B" ? "CLEARANCE" : "REPORTING";

      await this.invoiceRepository.createSubmission({
        invoice: { connect: { id: createdInvoice.id } },
        submissionType: submissionType,
        zatcaStatus: "PENDING",
        attemptCount: 0,
        qrCode: qrCode || null,
        zatcaResponse: null,
      });

      return createdInvoice;
    } catch (error) {
      this.logger.error(
        `Failed to persist invoice to database: ${error.message}`
      );
      throw new BadRequestException(
        `Database persistence failed: ${error.message}`
      );
    }
  }
}
