import {
  Injectable,
  Logger,
  BadRequestException,
  NotFoundException,
} from "@nestjs/common";
import { CliExecutorService } from "../common/cli-executor.service";
import { FileManagerService } from "../common/file-manager.service";
import { XmlTemplateService } from "./xml-template.service";
import { SignInvoiceDto } from "./dto/sign-invoice.dto";
import * as path from "path";

import { SequenceService } from "../common/sequence.service";
import { PrismaService } from "../prisma/prisma.service";

@Injectable()
export class InvoiceService {
  private readonly logger = new Logger(InvoiceService.name);

  constructor(
    private readonly cliExecutor: CliExecutorService,
    private readonly fileManager: FileManagerService,
    private readonly xmlTemplate: XmlTemplateService,
    private readonly sequenceService: SequenceService,
    private readonly prisma: PrismaService
  ) {}

  async signInvoice(dto: SignInvoiceDto) {
    const { egs, invoice } = dto;
    const commonName = egs.commonName;

    // 1. Generate Sequence Automatically (Ignore payload values)
    this.logger.log(`Generating automatic sequence for ${commonName}...`);
    const seqData = await this.sequenceService.generateNextSerialNumber(dto);
    invoice.invoiceSerialNumber = seqData.serialNumber;
    invoice.invoiceCounterNumber = seqData.counter;

    const serialNumber = invoice.invoiceSerialNumber;

    console.log("--------------------------------------------------");
    console.log("üìë INVOICE SIGNING: STARTING PROCESS");
    console.log(`üìç Profile: ${commonName}`);
    console.log(`üî¢ Serial: ${serialNumber}`);

    // 1. Load Keys and Certificate from DB (EgsUnit)
    const egsUnit = await this.prisma.egsUnit.findUnique({
      where: { commonName },
    });

    if (!egsUnit || !egsUnit.privateKey || !egsUnit.binarySecurityToken) {
      throw new NotFoundException(
        `Security tokens (key/cert) not found in database for ${commonName}. Please complete onboarding (steps 1 & 2) first.`
      );
    }

    // Reconstruct PEM-formatted key and certificate from compact DB values
    const formatPem = (body: string, header: string, footer: string) => {
      const chunks = body.match(/.{1,64}/g) || [body];
      return [header, ...chunks, footer, ""].join("\n");
    };

    const keyPem = formatPem(
      egsUnit.privateKey.trim(),
      "-----BEGIN PRIVATE KEY-----",
      "-----END PRIVATE KEY-----"
    );

    const certPem = formatPem(
      egsUnit.binarySecurityToken.trim(),
      "-----BEGIN CERTIFICATE-----",
      "-----END CERTIFICATE-----"
    );

    // Persist to onboarding folder to keep CLI contract unchanged
    const keyPath = await this.fileManager.writeOnboardingFile(
      commonName,
      "egs-signing-key.pem",
      keyPem
    );
    const certPath = await this.fileManager.writeOnboardingFile(
      commonName,
      "ccsid-certificate.pem",
      certPem
    );

    // 2. Generate Base XML
    const baseXml = this.xmlTemplate.generateInvoiceXml(dto);

    console.log("\n[PRE-SIGN] üìÑ Generated Base XML Structure:");
    console.log("--------------------------------------------------");
    console.log(baseXml);
    console.log("--------------------------------------------------");

    const unsignedPath = await this.fileManager.writeTempFile(
      commonName,
      `${serialNumber}_unsigned.xml`,
      baseXml
    );
    const tempDir = await this.fileManager.getTempDir(commonName);
    const signedPath = path.join(tempDir, `${serialNumber}_signed.xml`);

    console.log(`‚úÖ Base XML generated at: ${unsignedPath}`);

    // 3. Call Fatoora CLI to Sign
    console.log("üöÄ Calling Fatoora CLI to sign invoice...");

    try {
      const command = `fatoora -sign -invoice "${unsignedPath}" -key "${keyPath}" -cert "${certPath}" -signedInvoice "${signedPath}"`;
      const output = await this.cliExecutor.execute(command);

      console.log("‚úÖ Fatoora CLI Signing Output:");
      console.log(output);

      if (!(await this.fileManager.exists(signedPath))) {
        throw new Error(
          "Signed invoice file was not generated by Fatoora CLI."
        );
      }

      const signedXml = await this.fileManager.readFile(signedPath);

      console.log(
        "\n[POST-SIGN] üìù Final Signed XML Structure (ZATCA Compliant):"
      );
      console.log("--------------------------------------------------");
      console.log(signedXml);
      console.log("--------------------------------------------------");

      console.log("üéâ SUCCESS: Invoice signed successfully.");

      // Extract QR code from signed XML for the frontend
      const qrMatch = signedXml.match(
        /<cac:AdditionalDocumentReference>\s*<cbc:ID>QR<\/cbc:ID>\s*<cac:Attachment>\s*<cbc:EmbeddedDocumentBinaryObject[^>]*>([^<]+)<\/cbc:EmbeddedDocumentBinaryObject>/i
      );
      const qrCode = qrMatch ? qrMatch[1].trim() : undefined;

      return {
        signedXml,
        qrCode,
        fileName: `${serialNumber}_signed.xml`,
        message: "Invoice signed and QR code generated.",
      };
    } catch (error) {
      this.logger.error(`Fatoora Signing Failed: ${error.message}`);
      throw new BadRequestException(`ZATCA Signing Error: ${error.message}`);
    }
  }
}
