import {
  Injectable,
  Logger,
  BadRequestException,
  NotFoundException,
} from "@nestjs/common";
import { CliExecutorService } from "../common/cli-executor.service";
import { FileManagerService } from "../common/file-manager.service";
import { XmlTemplateService } from "./xml-template.service";
import { SignInvoiceDto } from "./dto/sign-invoice.dto";
import * as path from "path";

import { SequenceService } from "../common/sequence.service";
import { PrismaService } from "../prisma/prisma.service";
import { ComplianceService } from "../compliance/compliance.service";

@Injectable()
export class InvoiceService {
  private readonly logger = new Logger(InvoiceService.name);

  constructor(
    private readonly cliExecutor: CliExecutorService,
    private readonly fileManager: FileManagerService,
    private readonly xmlTemplate: XmlTemplateService,
    private readonly sequenceService: SequenceService,
    private readonly prisma: PrismaService,
    private readonly complianceService: ComplianceService
  ) {}

  async signInvoice(dto: SignInvoiceDto) {
    const { egs, invoice } = dto;
    const commonName = egs.commonName;

    console.log("\n========================================");
    console.log("[SIGN_INVOICE] Starting invoice signing...");
    console.log("[SIGN_INVOICE] Common Name:", commonName);
    console.log("[SIGN_INVOICE] Invoice Type Code:", invoice.invoiceTypeCode);
    console.log(
      "[SIGN_INVOICE] Invoice Type Code Name:",
      invoice.invoiceTypeCodeName
    );
    console.log("[SIGN_INVOICE] Is Production:", egs.production);

    // 1. Generate Sequence and Retrieve Chain Data (ICV and PIH)
    // 1. Generate Sequence and Retrieve Chain Data (ICV and PIH)
    const seqData = await this.sequenceService.generateNextSerialNumber(dto);

    invoice.invoiceSerialNumber = seqData.serialNumber;
    invoice.invoiceCounterNumber = seqData.counter;
    invoice.previousInvoiceHash = seqData.previousHash;

    const serialNumber = invoice.invoiceSerialNumber;

    // 1. Load Keys and Certificate from DB (EgsUnit)
    const egsUnit = await this.prisma.egsUnit.findUnique({
      where: { commonName },
    });

    if (!egsUnit || !egsUnit.privateKey || !egsUnit.binarySecurityToken) {
      throw new NotFoundException(
        `Security tokens (key/cert) not found in database for ${commonName}. Please complete onboarding (steps 1 & 2) first.`
      );
    }

    // Reconstruct PEM-formatted key and certificate from compact DB values
    const formatPem = (body: string, header: string, footer: string) => {
      const chunks = body.match(/.{1,64}/g) || [body];
      return [header, ...chunks, footer, ""].join("\n");
    };

    const keyPem = formatPem(
      egsUnit.privateKey.trim(),
      "-----BEGIN PRIVATE KEY-----",
      "-----END PRIVATE KEY-----"
    );

    const certPem = formatPem(
      egsUnit.binarySecurityToken.trim(),
      "-----BEGIN CERTIFICATE-----",
      "-----END CERTIFICATE-----"
    );

    // Persist to onboarding folder to keep CLI contract unchanged
    const keyPath = await this.fileManager.writeOnboardingFile(
      commonName,
      "egs-signing-key.pem",
      keyPem
    );
    const certPath = await this.fileManager.writeOnboardingFile(
      commonName,
      "ccsid-certificate.pem",
      certPem
    );

    // 2. Generate Base XML
    console.log("[XML_GEN] Generating base XML from template...");
    const baseXml = this.xmlTemplate.generateInvoiceXml(dto);
    console.log("[XML_GEN] Base XML length:", baseXml.length, "bytes");
    console.log(
      "[XML_GEN] Contains InvoiceTypeCode:",
      baseXml.includes("InvoiceTypeCode")
    );

    const unsignedPath = await this.fileManager.writeTempFile(
      commonName,
      `${serialNumber}_unsigned.xml`,
      baseXml
    );
    const tempDir = await this.fileManager.getTempDir(commonName);
    const signedPath = path.join(tempDir, `${serialNumber}_signed.xml`);

    // 3. Call Fatoora CLI to Sign

    try {
      const command = `fatoora -sign -invoice "${unsignedPath}" -key "${keyPath}" -cert "${certPath}" -signedInvoice "${signedPath}"`;
      const output = await this.cliExecutor.execute(command);

      if (!(await this.fileManager.exists(signedPath))) {
        throw new Error(
          "Signed invoice file was not generated by Fatoora CLI."
        );
      }

      const signedXml = await this.fileManager.readFile(signedPath);
      console.log("[SIGN] Signed XML generated successfully");
      console.log("[SIGN] Signed XML length:", signedXml.length, "bytes");

      // Extract UUID from signed XML
      const uuidMatch = signedXml.match(/<cbc:UUID>([^<]+)<\/cbc:UUID>/);
      const extractedUUID = uuidMatch ? uuidMatch[1].trim() : "NOT_FOUND";
      console.log("[EXTRACTION] Invoice UUID:", extractedUUID);

      // Extract Hash from signed XML
      const hashMatch = signedXml.match(/URI=""[\s\S]*?DigestValue>([^<]+)</);
      const extractedHash = hashMatch ? hashMatch[1].trim() : "NOT_FOUND";
      console.log("[EXTRACTION] Invoice Hash:", extractedHash);
      console.log(
        "[EXTRACTION] Hash length:",
        extractedHash.length,
        "(expected: 44)"
      );

      // Extract QR code from signed XML for the frontend
      const qrMatch = signedXml.match(
        /<cac:AdditionalDocumentReference>\s*<cbc:ID>QR<\/cbc:ID>\s*<cac:Attachment>\s*<cbc:EmbeddedDocumentBinaryObject[^>]*>([^<]+)<\/cbc:EmbeddedDocumentBinaryObject>/i
      );
      const qrCode = qrMatch ? qrMatch[1].trim() : undefined;
      console.log("[QR] QR Code extracted:", qrCode ? "YES" : "NO");
      if (qrCode) {
        console.log("[QR] QR Base64 length:", qrCode.length);
        console.log("[QR] QR first 50 chars:", qrCode.substring(0, 50) + "...");
      }

      // 4. PERSIST INVOICE TO DATABASE
      console.log("[DB] Persisting invoice to database...");

      const savedInvoice = await this.persistInvoiceToDatabase(
        dto,
        signedXml,
        qrCode,
        serialNumber
      );

      console.log("[DB] Invoice persisted successfully");
      console.log("[DB] Invoice ID:", savedInvoice.id);
      console.log("[DB] Invoice UUID:", savedInvoice.uuid);
      console.log("[DB] Invoice Number:", serialNumber);

      // IMPORTANT: Only increment counter after successful save
      await this.sequenceService.commitCounterIncrement(commonName);
      console.log("[COUNTER] Invoice counter incremented successfully");

      console.log("========================================\n");

      return {
        invoiceId: savedInvoice.id,
        invoiceUuid: savedInvoice.uuid,
        signedXml,
        qrCode,
        fileName: `${serialNumber}_signed.xml`,
        message: "Invoice signed and saved successfully.",
      };
    } catch (error) {
      this.logger.error(`Fatoora Signing Failed: ${error.message}`);
      throw new BadRequestException(`ZATCA Signing Error: ${error.message}`);
    } finally {
      // CLEANUP: Remove temporary files to avoid storage
      try {
        if (unsignedPath) await this.fileManager.deleteTemp(unsignedPath);
        if (signedPath && (await this.fileManager.exists(signedPath))) {
          await this.fileManager.deleteTemp(signedPath);
        }
      } catch (cleanupError) {
        console.warn(`⚠️ CLEANUP FAILED: ${cleanupError.message}`);
      }
    }
  }

  async listInvoices(commonName: string) {
    return this.prisma.invoice.findMany({
      where: { commonName },
      orderBy: { issueDateTime: "desc" },
      select: {
        id: true,
        invoiceNumber: true,
        issueDateTime: true,
        invoiceCategory: true,
        totalAmount: true,
        status: true,
        createdAt: true,
        submission: {
          select: {
            zatcaStatus: true,
            reportingStatus: true,
            clearanceStatus: true,
          },
        },
      },
    });
  }

  async getInvoiceByNumber(invoiceNumber: string) {
    const invoice = await this.prisma.invoice.findUnique({
      where: { invoiceNumber },
      include: {
        items: true,
        hash: true,
        submission: true,
      },
    });

    if (!invoice) {
      throw new NotFoundException(`Invoice ${invoiceNumber} not found`);
    }

    return invoice;
  }

  async getZatcaResponse(invoiceNumber: string) {
    const submission = await this.prisma.zatcaSubmission.findFirst({
      where: { invoice: { invoiceNumber } },
    });

    if (!submission) {
      throw new NotFoundException(
        `Submission record for ${invoiceNumber} not found`
      );
    }

    return submission.zatcaResponse;
  }

  /**
   * Persists the complete invoice to the database following the Prisma schema structure
   * EXTRACTS all data from the CLI-generated signed XML (no custom logic)
   * Includes extensive console logging for debugging every step
   */
  private async persistInvoiceToDatabase(
    dto: SignInvoiceDto,
    signedXml: string,
    qrCode: string | undefined,
    serialNumber: string
  ) {
    const { egs, invoice, supplier, customer, lineItems, totals } = dto;

    // =====================================================
    // EXTRACT DATA FROM CLI-GENERATED SIGNED XML
    // =====================================================

    // Extract UUID (generated by Fatoora CLI)
    const uuidMatch = signedXml.match(/<cbc:UUID>([^<]+)<\/cbc:UUID>/);
    const cliGeneratedUuid = uuidMatch ? uuidMatch[1].trim() : null;

    // Extract Issue Date/Time (generated by Fatoora CLI)
    const issueDateMatch = signedXml.match(
      /<cbc:IssueDate>([^<]+)<\/cbc:IssueDate>/
    );
    const issueTimeMatch = signedXml.match(
      /<cbc:IssueTime>([^<]+)<\/cbc:IssueTime>/
    );

    let cliIssueDateTime = new Date();
    if (issueDateMatch && issueTimeMatch) {
      const dateStr = issueDateMatch[1].trim();
      const timeStr = issueTimeMatch[1].trim();
      cliIssueDateTime = new Date(`${dateStr}T${timeStr}`);
    }

    // Extract Invoice Hash (PIH - Previous Invoice Hash from XML)
    const pihMatch = signedXml.match(
      /<cbc:ID>PIH<\/cbc:ID>[\s\S]*?<cbc:EmbeddedDocumentBinaryObject[^>]*>([^<]+)<\/cbc:EmbeddedDocumentBinaryObject>/
    );
    const previousInvoiceHash = pihMatch
      ? pihMatch[1].trim()
      : "NWZlY2ViOTZmOTk1YTRiMGNjM2YwOTUwZGYzMmM2YjQ5ZGEyN2IyOA==";

    // Extract Invoice Counter (ICV) from XML
    const icvMatch = signedXml.match(
      /<cbc:ID>ICV<\/cbc:ID>[\s\S]*?<cbc:EmbeddedDocumentBinaryObject[^>]*>([^<]+)<\/cbc:EmbeddedDocumentBinaryObject>/
    );
    const invoiceCounter = icvMatch
      ? icvMatch[1].trim()
      : invoice.invoiceCounterNumber?.toString() || "1";

    // Extract Actual Invoice Hash (Digest Value for ZATCA)
    // Must be the digest of the info being signed (Reference URI="")
    // Regex: Look for URI="" (which indicates the main document reference)
    // and then capture the next DigestValue. This ignores tag prefixes and attribute order.
    const invoiceHashMatch = signedXml.match(
      /URI=""[\s\S]*?DigestValue>([^<]+)</
    );
    const currentInvoiceHash = invoiceHashMatch
      ? invoiceHashMatch[1].trim()
      : "HASH_NOT_FOUND";

    if (currentInvoiceHash === "HASH_NOT_FOUND") {
      // Fallback: If regex fails, we might rely on the PIH? No, that's previous.
    }

    // Determine invoice type description
    const invoiceTypeMap = {
      "388": "TAX INVOICE",
      "381": "CREDIT NOTE",
      "383": "DEBIT NOTE",
      "386": "PREPAYMENT INVOICE",
      "380": "COMMERCIAL INVOICE",
    };

    const invoiceTypeLabel =
      invoiceTypeMap[invoice.invoiceTypeCode] || "UNKNOWN";

    if (!cliGeneratedUuid) {
      throw new BadRequestException(
        "Failed to extract UUID from signed XML. CLI may have failed."
      );
    }

    // Combine address fields into single strings for database storage
    const formatAddress = (addr: any) => {
      if (!addr) return "N/A";
      const parts = [];
      if (addr.street) parts.push(addr.street);
      if (addr.buildingNumber) parts.push(`Bldg ${addr.buildingNumber}`);
      if (addr.district) parts.push(addr.district);
      if (addr.city) parts.push(addr.city);
      if (addr.postalCode) parts.push(addr.postalCode);
      if (addr.country) parts.push(addr.country);
      return parts.length > 0 ? parts.join(", ") : "N/A";
    };

    try {
      // Step 1: Create main Invoice record using CLI-extracted data
      const createdInvoice = await this.prisma.invoice.create({
        data: {
          invoiceNumber: serialNumber,
          uuid: cliGeneratedUuid, // ✅ USE CLI-GENERATED UUID
          invoiceTypeCode: invoice.invoiceTypeCode,
          invoiceTypeCodeName:
            invoice.invoiceTypeCodeName ||
            (customer?.type === "B2B" ? "0111010" : "0211010"),
          invoiceCategory: customer?.type === "B2B" ? "STANDARD" : "SIMPLIFIED",
          issueDateTime: cliIssueDateTime, // ✅ USE CLI-GENERATED TIMESTAMP

          // EGS Reference
          commonName: egs.commonName,

          // Seller Info (from request DTO with combined address)
          sellerName: supplier.registrationName,
          sellerVatNumber: supplier.vatNumber,
          sellerAddress: formatAddress(supplier.address),

          // Buyer Info (Optional for B2C with combined address)
          buyerName: customer?.name || null,
          buyerVatNumber: customer?.vatNumber || null,
          buyerAddress: formatAddress(customer?.address),

          // References (for Credit/Debit Notes)
          referenceInvoiceNumber: invoice.billingReferenceId || null,
          referenceUUID: null,
          referenceIssueDate: null,

          // Advance Payments
          prepaidAmount: 0,
          remainingAmount: totals.taxInclusiveTotal,

          // Totals (from request DTO)
          subTotal: totals.taxExclusiveTotal,
          vatAmount: totals.vatTotal,
          totalAmount: totals.taxInclusiveTotal,
          currency: invoice.currency || "SAR",

          // Signed XML (CLI output)
          signedXml: signedXml,
          qrCode: qrCode || null,

          // Status
          status: "ISSUED",
        },
      });

      // Step 2: Create Invoice Items (from request DTO)
      // Step 2: Create Line Items
      const itemsData = lineItems.map((item, index) => {
        return {
          invoiceId: createdInvoice.id,
          description: item.description,
          quantity: item.quantity,
          unitPrice: item.unitPrice,
          vatRate: item.vatPercent,
          vatAmount: item.vatAmount,
          totalAmount: item.taxExclusiveAmount + item.vatAmount,
        };
      });

      await this.prisma.invoiceItem.createMany({
        data: itemsData,
      });

      // Step 3: Create Invoice Hash Record (using CLI-extracted hash)
      await this.prisma.invoiceHash.create({
        data: {
          invoiceId: createdInvoice.id,
          previousInvoiceHash: previousInvoiceHash, // ✅ FROM CLI XML (PIH)
          currentInvoiceHash: currentInvoiceHash, // ✅ ACTUAL HASH (DigestValue)
        },
      });

      // Step 4: Initialize ZATCA Submission Record
      // Step 4: Initialize ZATCA Submission Record
      const submissionType =
        customer?.type === "B2B" ? "CLEARANCE" : "REPORTING";

      await this.prisma.zatcaSubmission.create({
        data: {
          invoiceId: createdInvoice.id,
          submissionType: submissionType,
          zatcaStatus: "PENDING",
          attemptCount: 0,
          qrCode: qrCode || null,
          zatcaResponse: null,
        },
      });

      return createdInvoice;
    } catch (error) {
      this.logger.error(
        `Failed to persist invoice to database: ${error.message}`
      );
      throw new BadRequestException(
        `Database persistence failed: ${error.message}`
      );
    }
  }
}
