import {
  Injectable,
  Logger,
  BadRequestException,
  NotFoundException,
} from "@nestjs/common";
import { CliExecutorService } from "../common/cli-executor.service";
import { FileManagerService } from "../common/file-manager.service";
import { XmlTemplateService } from "./xml-template.service";
import { SignInvoiceDto } from "./dto/sign-invoice.dto";
import * as path from "path";

import { SequenceService } from "../common/sequence.service";
import { PrismaService } from "../prisma/prisma.service";
import { ComplianceService } from "../compliance/compliance.service";

@Injectable()
export class InvoiceService {
  private readonly logger = new Logger(InvoiceService.name);

  constructor(
    private readonly cliExecutor: CliExecutorService,
    private readonly fileManager: FileManagerService,
    private readonly xmlTemplate: XmlTemplateService,
    private readonly sequenceService: SequenceService,
    private readonly prisma: PrismaService,
    private readonly complianceService: ComplianceService
  ) {}

  async signInvoice(dto: SignInvoiceDto) {
    const { egs, invoice } = dto;
    const commonName = egs.commonName;

    // 1. Generate Sequence and Retrieve Chain Data (ICV and PIH)
    this.logger.log(`Generating automatic sequence for ${commonName}...`);
    const seqData = await this.sequenceService.generateNextSerialNumber(dto);

    invoice.invoiceSerialNumber = seqData.serialNumber;
    invoice.invoiceCounterNumber = seqData.counter;
    invoice.previousInvoiceHash = seqData.previousHash;

    const serialNumber = invoice.invoiceSerialNumber;

    console.log("--------------------------------------------------");
    console.log("ğŸ“‘ INVOICE SIGNING: STARTING PROCESS");
    console.log(`ğŸ“ Profile: ${commonName}`);
    console.log(`ğŸ”¢ Serial: ${serialNumber}`);

    // 1. Load Keys and Certificate from DB (EgsUnit)
    const egsUnit = await this.prisma.egsUnit.findUnique({
      where: { commonName },
    });

    if (!egsUnit || !egsUnit.privateKey || !egsUnit.binarySecurityToken) {
      throw new NotFoundException(
        `Security tokens (key/cert) not found in database for ${commonName}. Please complete onboarding (steps 1 & 2) first.`
      );
    }

    // Reconstruct PEM-formatted key and certificate from compact DB values
    const formatPem = (body: string, header: string, footer: string) => {
      const chunks = body.match(/.{1,64}/g) || [body];
      return [header, ...chunks, footer, ""].join("\n");
    };

    const keyPem = formatPem(
      egsUnit.privateKey.trim(),
      "-----BEGIN PRIVATE KEY-----",
      "-----END PRIVATE KEY-----"
    );

    const certPem = formatPem(
      egsUnit.binarySecurityToken.trim(),
      "-----BEGIN CERTIFICATE-----",
      "-----END CERTIFICATE-----"
    );

    // Persist to onboarding folder to keep CLI contract unchanged
    const keyPath = await this.fileManager.writeOnboardingFile(
      commonName,
      "egs-signing-key.pem",
      keyPem
    );
    const certPath = await this.fileManager.writeOnboardingFile(
      commonName,
      "ccsid-certificate.pem",
      certPem
    );

    // 2. Generate Base XML
    const baseXml = this.xmlTemplate.generateInvoiceXml(dto);

    console.log("\n[PRE-SIGN] ğŸ“„ Generated Base XML Structure:");
    console.log("--------------------------------------------------");
    console.log(baseXml);
    console.log("--------------------------------------------------");

    const unsignedPath = await this.fileManager.writeTempFile(
      commonName,
      `${serialNumber}_unsigned.xml`,
      baseXml
    );
    const tempDir = await this.fileManager.getTempDir(commonName);
    const signedPath = path.join(tempDir, `${serialNumber}_signed.xml`);

    console.log(`âœ… Base XML generated at: ${unsignedPath}`);

    // 3. Call Fatoora CLI to Sign
    console.log("ğŸš€ Calling Fatoora CLI to sign invoice...");

    try {
      const command = `fatoora -sign -invoice "${unsignedPath}" -key "${keyPath}" -cert "${certPath}" -signedInvoice "${signedPath}"`;
      const output = await this.cliExecutor.execute(command);

      console.log("âœ… Fatoora CLI Signing Output:");
      console.log(output);

      if (!(await this.fileManager.exists(signedPath))) {
        throw new Error(
          "Signed invoice file was not generated by Fatoora CLI."
        );
      }

      const signedXml = await this.fileManager.readFile(signedPath);

      console.log(
        "\n[POST-SIGN] ğŸ“ Final Signed XML Structure (ZATCA Compliant):"
      );
      console.log("--------------------------------------------------");
      console.log(signedXml);
      console.log("--------------------------------------------------");

      console.log("ğŸ‰ SUCCESS: Invoice signed successfully.");

      // Extract QR code from signed XML for the frontend
      const qrMatch = signedXml.match(
        /<cac:AdditionalDocumentReference>\s*<cbc:ID>QR<\/cbc:ID>\s*<cac:Attachment>\s*<cbc:EmbeddedDocumentBinaryObject[^>]*>([^<]+)<\/cbc:EmbeddedDocumentBinaryObject>/i
      );
      const qrCode = qrMatch ? qrMatch[1].trim() : undefined;

      // 4. PERSIST INVOICE TO DATABASE
      console.log(
        "\nğŸ”¥ğŸ”¥ğŸ”¥ CRITICAL: ABOUT TO CALL persistInvoiceToDatabase ğŸ”¥ğŸ”¥ğŸ”¥"
      );
      console.log(
        `ğŸ“Œ Serial: ${serialNumber} | QR Length: ${qrCode?.length || 0} | XML Length: ${signedXml.length}`
      );

      const savedInvoice = await this.persistInvoiceToDatabase(
        dto,
        signedXml,
        qrCode,
        serialNumber
      );

      console.log("âœ…âœ…âœ… DATABASE PERSISTENCE COMPLETED!");
      console.log(
        `ğŸ’¾ Saved Invoice ID: ${savedInvoice.id} | UUID: ${savedInvoice.uuid}`
      );

      // 6. SUBMIT TO ZATCA (AUTO-TRIGGER)
      console.log("\nğŸš€ AUTOMATED ZATCA SUBMISSION TRIGGERED...");
      let submissionStatus = "PENDING_SUBMISSION";
      let submissionResult = null;

      try {
        submissionResult = await this.complianceService.submitToZatca({
          commonName: dto.egs.commonName,
          invoiceSerialNumber: serialNumber,
          production: dto.egs.production || false,
        });
        submissionStatus = "SUBMITTED";
        console.log(`âœ… [ZATCA] Auto-Submission Successful.`);
      } catch (submitError) {
        console.error(
          `âŒ [ZATCA] Auto-Submission Failed: ${submitError.message}`
        );
        submissionStatus = "FAILED";
      }

      return {
        invoiceId: savedInvoice.id,
        invoiceUuid: savedInvoice.uuid,
        signedXml,
        qrCode,
        fileName: `${serialNumber}_signed.xml`,
        message: "Invoice signed, saved, and submitted to ZATCA.",
        zatcaStatus: submissionStatus,
        submissionResult,
      };
    } catch (error) {
      this.logger.error(`Fatoora Signing Failed: ${error.message}`);
      throw new BadRequestException(`ZATCA Signing Error: ${error.message}`);
    } finally {
      // CLEANUP: Remove temporary files to avoid storage
      try {
        if (unsignedPath) await this.fileManager.deleteTemp(unsignedPath);
        if (signedPath && (await this.fileManager.exists(signedPath))) {
          await this.fileManager.deleteTemp(signedPath);
        }
        console.log("ğŸ§¹ CLEANUP: Temporary CLI files removed.");
      } catch (cleanupError) {
        console.warn(`âš ï¸ CLEANUP FAILED: ${cleanupError.message}`);
      }
    }
  }

  async listInvoices(commonName: string) {
    return this.prisma.invoice.findMany({
      where: { commonName },
      orderBy: { issueDateTime: "desc" },
      select: {
        id: true,
        invoiceNumber: true,
        issueDateTime: true,
        invoiceCategory: true,
        totalAmount: true,
        status: true,
        submission: {
          select: {
            zatcaStatus: true,
            reportingStatus: true,
            clearanceStatus: true,
          },
        },
      },
    });
  }

  async getInvoiceByNumber(invoiceNumber: string) {
    const invoice = await this.prisma.invoice.findUnique({
      where: { invoiceNumber },
      include: {
        items: true,
        hash: true,
        submission: true,
      },
    });

    if (!invoice) {
      throw new NotFoundException(`Invoice ${invoiceNumber} not found`);
    }

    return invoice;
  }

  async getZatcaResponse(invoiceNumber: string) {
    const submission = await this.prisma.zatcaSubmission.findFirst({
      where: { invoice: { invoiceNumber } },
    });

    if (!submission) {
      throw new NotFoundException(
        `Submission record for ${invoiceNumber} not found`
      );
    }

    return submission.zatcaResponse;
  }

  /**
   * Persists the complete invoice to the database following the Prisma schema structure
   * EXTRACTS all data from the CLI-generated signed XML (no custom logic)
   * Includes extensive console logging for debugging every step
   */
  private async persistInvoiceToDatabase(
    dto: SignInvoiceDto,
    signedXml: string,
    qrCode: string | undefined,
    serialNumber: string
  ) {
    console.log("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    console.log("â•‘   ğŸ’¾ DATABASE PERSISTENCE STARTING                   â•‘");
    console.log("â•‘   ğŸ¯ EXTRACTING CLI-GENERATED DATA FROM XML          â•‘");
    console.log("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

    const { egs, invoice, supplier, customer, lineItems, totals } = dto;

    // =====================================================
    // EXTRACT DATA FROM CLI-GENERATED SIGNED XML
    // =====================================================
    console.log("\n[INVOICE-DB] ğŸ” Parsing CLI-generated signed XML...");

    // Extract UUID (generated by Fatoora CLI)
    const uuidMatch = signedXml.match(/<cbc:UUID>([^<]+)<\/cbc:UUID>/);
    const cliGeneratedUuid = uuidMatch ? uuidMatch[1].trim() : null;
    console.log(`[INVOICE-DB]    âœ“ CLI UUID: ${cliGeneratedUuid}`);

    // Extract Issue Date/Time (generated by Fatoora CLI)
    const issueDateMatch = signedXml.match(
      /<cbc:IssueDate>([^<]+)<\/cbc:IssueDate>/
    );
    const issueTimeMatch = signedXml.match(
      /<cbc:IssueTime>([^<]+)<\/cbc:IssueTime>/
    );

    let cliIssueDateTime = new Date();
    if (issueDateMatch && issueTimeMatch) {
      const dateStr = issueDateMatch[1].trim();
      const timeStr = issueTimeMatch[1].trim();
      cliIssueDateTime = new Date(`${dateStr}T${timeStr}`);
      console.log(
        `[INVOICE-DB]    âœ“ CLI IssueDateTime: ${cliIssueDateTime.toISOString()}`
      );
    } else {
      console.log(
        `[INVOICE-DB]    âš  CLI IssueDateTime not found in XML, using current time`
      );
    }

    // Extract Invoice Hash (PIH - Previous Invoice Hash from XML)
    const pihMatch = signedXml.match(
      /<cbc:ID>PIH<\/cbc:ID>[\s\S]*?<cbc:EmbeddedDocumentBinaryObject[^>]*>([^<]+)<\/cbc:EmbeddedDocumentBinaryObject>/
    );
    const previousInvoiceHash = pihMatch
      ? pihMatch[1].trim()
      : "NWZlY2ViOTZmOTk1YTRiMGNjM2YwOTUwZGYzMmM2YjQ5ZGEyN2IyOA==";
    console.log(
      `[INVOICE-DB]    âœ“ Previous Hash (PIH): ${previousInvoiceHash.substring(0, 20)}...`
    );

    // Extract Invoice Counter (ICV) from XML
    const icvMatch = signedXml.match(
      /<cbc:ID>ICV<\/cbc:ID>[\s\S]*?<cbc:EmbeddedDocumentBinaryObject[^>]*>([^<]+)<\/cbc:EmbeddedDocumentBinaryObject>/
    );
    const invoiceCounter = icvMatch
      ? icvMatch[1].trim()
      : invoice.invoiceCounterNumber?.toString() || "1";
    console.log(`[INVOICE-DB]    âœ“ Invoice Counter (ICV): ${invoiceCounter}`);

    // Extract Actual Invoice Hash (Digest Value for ZATCA)
    // Must be the digest of the info being signed (Reference URI="")
    // Regex: Look for URI="" (which indicates the main document reference)
    // and then capture the next DigestValue. This ignores tag prefixes and attribute order.
    const invoiceHashMatch = signedXml.match(
      /URI=""[\s\S]*?DigestValue>([^<]+)</
    );
    const currentInvoiceHash = invoiceHashMatch
      ? invoiceHashMatch[1].trim()
      : "HASH_NOT_FOUND";
    console.log(`[INVOICE-DB]    âœ“ Actual Invoice Hash: ${currentInvoiceHash}`);

    if (currentInvoiceHash === "HASH_NOT_FOUND") {
      console.warn("âš ï¸ WARNING: Could not extract Invoice Hash from XML!");
      // Fallback: If regex fails, we might rely on the PIH? No, that's previous.
    }

    // Determine invoice type description
    const invoiceTypeMap = {
      "388": "TAX INVOICE",
      "381": "CREDIT NOTE",
      "383": "DEBIT NOTE",
      "386": "PREPAYMENT INVOICE",
      "380": "COMMERCIAL INVOICE",
    };

    const invoiceTypeLabel =
      invoiceTypeMap[invoice.invoiceTypeCode] || "UNKNOWN";

    console.log(`\n[INVOICE-DB] ğŸ“Š Invoice Details:`);
    console.log(
      `[INVOICE-DB]    Type: ${invoiceTypeLabel} (${invoice.invoiceTypeCode})`
    );
    console.log(`[INVOICE-DB]    Serial: ${serialNumber}`);
    console.log(`[INVOICE-DB]    EGS: ${egs.commonName}`);
    console.log(
      `[INVOICE-DB]    Total: ${totals.taxInclusiveTotal.toLocaleString()} SAR`
    );
    console.log(`[INVOICE-DB]    Items: ${lineItems.length}`);
    console.log(
      `[INVOICE-DB]    Category: ${customer?.type === "B2B" ? "STANDARD" : "SIMPLIFIED"}`
    );

    if (!cliGeneratedUuid) {
      console.error(
        "[INVOICE-DB] âŒ CRITICAL: UUID not found in CLI-generated XML!"
      );
      throw new BadRequestException(
        "Failed to extract UUID from signed XML. CLI may have failed."
      );
    }

    try {
      console.log(`\n[INVOICE-DB] ğŸ”¨ Creating Invoice Record...`);
      console.log(`[INVOICE-DB] ğŸ” Data to insert:`, {
        invoiceNumber: serialNumber,
        uuid: cliGeneratedUuid,
        invoiceTypeCode: invoice.invoiceTypeCode,
        commonName: egs.commonName,
        sellerName: supplier.registrationName,
        totalAmount: totals.taxInclusiveTotal,
      });

      // Step 1: Create main Invoice record using CLI-extracted data
      console.log(`[INVOICE-DB] â³ Calling prisma.invoice.create...`);
      const createdInvoice = await this.prisma.invoice.create({
        data: {
          invoiceNumber: serialNumber,
          uuid: cliGeneratedUuid, // âœ… USE CLI-GENERATED UUID
          invoiceTypeCode: invoice.invoiceTypeCode,
          invoiceTypeCodeName:
            invoice.invoiceTypeCodeName ||
            (customer?.type === "B2B" ? "0111010" : "0211010"),
          invoiceCategory: customer?.type === "B2B" ? "STANDARD" : "SIMPLIFIED",
          issueDateTime: cliIssueDateTime, // âœ… USE CLI-GENERATED TIMESTAMP

          // EGS Reference
          commonName: egs.commonName,

          // Seller Info (from request DTO)
          sellerName: supplier.registrationName,
          sellerVatNumber: supplier.vatNumber,
          sellerAddress: supplier.address?.street || "N/A",

          // Buyer Info (Optional for B2C)
          buyerName: customer?.name || null,
          buyerVatNumber: customer?.vatNumber || null,
          buyerAddress: customer?.address?.street || null,

          // References (for Credit/Debit Notes)
          referenceInvoiceNumber: invoice.billingReferenceId || null,
          referenceUUID: null,
          referenceIssueDate: null,

          // Advance Payments
          prepaidAmount: 0,
          remainingAmount: totals.taxInclusiveTotal,

          // Totals (from request DTO)
          subTotal: totals.taxExclusiveTotal,
          vatAmount: totals.vatTotal,
          totalAmount: totals.taxInclusiveTotal,
          currency: invoice.currency || "SAR",

          // Signed XML (CLI output)
          signedXml: signedXml,
          qrCode: qrCode || null,

          // Status
          status: "ISSUED",
        },
      });

      console.log(`[INVOICE-DB] âœ… Invoice Record Created!`);
      console.log(`[INVOICE-DB]    DB ID: ${createdInvoice.id}`);
      console.log(`[INVOICE-DB]    UUID: ${createdInvoice.uuid}`);
      console.log(
        `[INVOICE-DB]    Issue Date: ${createdInvoice.issueDateTime.toISOString()}`
      );

      // Step 2: Create Invoice Items (from request DTO)
      console.log(`\n[INVOICE-DB] ğŸ“¦ Creating Line Items...`);

      const itemsData = lineItems.map((item, index) => {
        console.log(`[INVOICE-DB]    Item ${index + 1}: ${item.description}`);
        console.log(
          `[INVOICE-DB]       Qty: ${item.quantity} x ${item.unitPrice} SAR = ${item.taxExclusiveAmount} SAR`
        );
        console.log(
          `[INVOICE-DB]       VAT: ${item.vatPercent}% = ${item.vatAmount} SAR`
        );

        return {
          invoiceId: createdInvoice.id,
          description: item.description,
          quantity: item.quantity,
          unitPrice: item.unitPrice,
          vatRate: item.vatPercent,
          vatAmount: item.vatAmount,
          totalAmount: item.taxExclusiveAmount + item.vatAmount,
        };
      });

      await this.prisma.invoiceItem.createMany({
        data: itemsData,
      });

      console.log(
        `[INVOICE-DB] âœ… Line Items Persisted (${lineItems.length} items)`
      );

      // Step 3: Create Invoice Hash Record (using CLI-extracted hash)
      console.log(`\n[INVOICE-DB] ğŸ” Creating Hash Chain Record...`);

      await this.prisma.invoiceHash.create({
        data: {
          invoiceId: createdInvoice.id,
          previousInvoiceHash: previousInvoiceHash, // âœ… FROM CLI XML (PIH)
          currentInvoiceHash: currentInvoiceHash, // âœ… ACTUAL HASH (DigestValue)
        },
      });

      console.log(`[INVOICE-DB] âœ… Hash Record Created`);
      console.log(
        `[INVOICE-DB]    Chain: ...${previousInvoiceHash.substring(0, 10)} -> ${createdInvoice.uuid.substring(0, 10)}...`
      );

      // Step 4: Initialize ZATCA Submission Record
      console.log(`\n[INVOICE-DB] ğŸ“¤ Initializing ZATCA Submission Record...`);

      const submissionType =
        customer?.type === "B2B" ? "CLEARANCE" : "REPORTING";

      await this.prisma.zatcaSubmission.create({
        data: {
          invoiceId: createdInvoice.id,
          submissionType: submissionType,
          zatcaStatus: "PENDING",
          attemptCount: 0,
          qrCode: qrCode || null,
          zatcaResponse: null,
        },
      });

      console.log(`[INVOICE-DB] âœ… Submission Record Initialized`);
      console.log(`[INVOICE-DB]    Type: ${submissionType}`);
      console.log(`[INVOICE-DB]    Status: PENDING`);

      console.log(
        "\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
      );
      console.log("â•‘   ğŸ‰ DATABASE PERSISTENCE COMPLETE!                  â•‘");
      console.log(
        "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n"
      );

      console.log(`[INVOICE-DB] ğŸ“Š Final Summary:`);
      console.log(`[INVOICE-DB]    âœ“ Invoice: ${createdInvoice.invoiceNumber}`);
      console.log(`[INVOICE-DB]    âœ“ UUID (CLI): ${createdInvoice.uuid}`);
      console.log(`[INVOICE-DB]    âœ“ Items: ${lineItems.length}`);
      console.log(`[INVOICE-DB]    âœ“ Total: ${totals.taxInclusiveTotal} SAR`);
      console.log(`[INVOICE-DB]    âœ“ Hash Chain: Updated (CLI PIH)`);
      console.log(`[INVOICE-DB]    âœ“ ZATCA: Ready for ${submissionType}`);
      console.log(`[INVOICE-DB]    âœ“ XML File: ${serialNumber}_signed.xml`);

      return createdInvoice;
    } catch (error) {
      console.error("\nâŒ [INVOICE-DB] DATABASE PERSISTENCE FAILED!");
      console.error(`[INVOICE-DB] Error: ${error.message}`);
      console.error(`[INVOICE-DB] Stack: ${error.stack}`);

      this.logger.error(
        `Failed to persist invoice to database: ${error.message}`
      );
      throw new BadRequestException(
        `Database persistence failed: ${error.message}`
      );
    }
  }
}
